using System;
using System.Collections.Generic;
using GraphForms.Algorithms.Collections;
using GraphForms.Algorithms.Layout.Circular;
using GraphForms.Algorithms.SpanningTree;

namespace GraphForms.Algorithms.Layout.Tree
{
    public class BalloonTreeLayoutAlgorithm<Node, Edge>
        : ATreeLayoutAlgorithm<Node, Edge, CircleGeom<Node, Edge>>
        where Node : class, ILayoutNode
        where Edge : class, IGraphEdge<Node>, IUpdateable
    {
        // Balloon Tree Generating Parameters
        //private SpanningTreeGen mSpanTreeGen = SpanningTreeGen.DFS;
        //private TreeRootFinding mRootFindingMethod = TreeRootFinding.Center;

        // Sorting Parameters
        private bool bInSketchMode = false;
        private IComparer<GTree<Node, Edge, CircleGeom<Node, Edge>>> mBranchSorter = null;

        // Position Calculation Paramaters
        private CircleSpacing mBranchSpacing = CircleSpacing.SNS;
        private CircleCentering mRootCentering = CircleCentering.Predefined;
        private double mMinEdgeLen = 10.0;
        private bool bEqualizeBranches = true;
        private double mMaxRootWedge = 2 * Math.PI;
        private double mMaxTreeWedge = Math.PI * 350.0 / 180.0;

        // Physical Animation Parameters
        private bool bAdaptToSizeChanges = false;
        private bool bAdjustRoots = true;
        private bool bAdjustAngle = false;
        private double mSpringMult = 10;
        private double mMagnetMult = 100;
        private double mMagnetExp = 1;
        private double mRootAngle = 0;

        // Flags and Calculated Values

        //private bool bSpanTreeDirty = true;
        //private Digraph<Node, Edge> mSpanTree;
        
        private bool bCircleTreeDirty = true;
        //private int mTreeSize;
        //private CircleTree<Node, Edge> mCircleTree;

        private bool bPositionsDirty = true;
        private double mCX;
        private double mCY;

        public BalloonTreeLayoutAlgorithm(Digraph<Node, Edge> graph,
            IClusterNode clusterNode)
            : base(graph, clusterNode)
        {
        }

        public BalloonTreeLayoutAlgorithm(Digraph<Node, Edge> graph,
            Box2F boundingBox)
            : base(graph, boundingBox)
        {
        }

        /*/// <summary>
        /// Gets the balloon tree data structure generated by this layout  
        /// algorithm based on <see cref="SpanningTreeGeneration"/> and 
        /// <see cref="RootFindingMethod"/> (or null if it hasn't been
        /// generated yet).</summary>
        protected CircleTree<Node, Edge> BalloonTree
        {
            get 
            {
                this.PerformPrecalculations();
                return this.mCircleTree; 
            }
        }/* */

        public double CentroidX
        {
            get
            {
                this.PerformPrecalculations();
                return this.mCX;
            }
        }

        public double CentroidY
        {
            get
            {
                this.PerformPrecalculations();
                return this.mCY;
            }
        }

        #region Parameters

        /*
        #region Balloon Tree Generating Parameters
        /// <summary>
        /// Gets or sets the method this algorithm uses to build its internal
        /// sparsely connected spanning tree for traversing its graph.
        /// </summary>
        public SpanningTreeGen SpanningTreeGeneration
        {
            get { return this.mSpanTreeGen; }
            set
            {
                if (this.mSpanTreeGen != value)
                {
                    this.mSpanTreeGen = value;
                    this.bSpanTreeDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets the method this algorithm uses to choose the root
        /// node from which all subtrees branch off and orbit around.
        /// </summary>
        public TreeRootFinding RootFindingMethod
        {
            get { return this.mRootFindingMethod; }
            set
            {
                if (this.mRootFindingMethod != value)
                {
                    this.mRootFindingMethod = value;
                    this.bCircleTreeDirty = true;
                }
            }
        }
        #endregion
        /* */

        #region Sorting Parameters
        /// <summary>
        /// Gets or sets whether this balloon tree layout algorithm is in
        /// "sketch mode", in which it arranges subtree/leaf nodes around
        /// their respective root nodes based on their original positions
        /// relative to their roots (in other words, from the original
        /// "sketch" of the graph before this layout algorithm was applied
        /// to it).</summary><remarks>
        /// Be aware that if this mode is enabled, this will supersede
        /// <see cref="BranchSorter"/> and it will be used instead to 
        /// arrange subtrees/leaves around their roots.</remarks>
        public bool InSketchMode
        {
            get { return this.bInSketchMode; }
            set
            {
                if (this.bInSketchMode != value &&
                    this.State != ComputeState.Running &&
                    this.AsyncState != ComputeState.Running)
                {
                    this.bInSketchMode = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets the comparer used to sort subtrees/leaves in the
        /// order in which they will be arranged counterclockwise around
        /// their root from -π (-180°) to π (180°).
        /// </summary><remarks>
        /// Be aware that this is superseded by <see cref="InSketchMode"/>
        /// and won't be used if "sketch mode" is enabled.</remarks>
        public IComparer<GTree<Node, Edge, CircleGeom<Node, Edge>>> BranchSorter
        {
            get { return this.mBranchSorter; }
            set
            {
                if (this.mBranchSorter != value)
                {
                    this.mBranchSorter = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        #endregion

        #region Position Calculation Parameters
        /// <summary>
        /// Gets or sets the method this algorithm uses to calculate the
        /// angles between subtrees/leaves around their root.
        /// </summary><remarks>
        /// If set to <see cref="CircleSpacing.SNS"/>, the angle computation 
        /// will use the subtree's/leaf's bounding wedge defined by its 
        /// <see cref="P:CircleTree`2.UpperWedge"/> and 
        /// <see cref="P:CircleTree`2.LowerWedge"/> properties
        /// calculated by <see cref="M:CircleTree`2.CalculateAngles()"/>.
        /// </remarks>
        public CircleSpacing BranchSpacing
        {
            get { return this.mBranchSpacing; }
            set
            {
                if (this.mBranchSpacing != value)
                {
                    this.mBranchSpacing = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets the method that this algorithm uses to calculate
        /// the initial position of the root of the entire balloon tree.
        /// </summary><remarks>
        /// Be aware that if the position of the root node of the entire 
        /// balloon tree is fixed,
        /// this value is irrelevant (or basically equivalent to 
        /// <see cref="CircleCentering.Predefined"/>, even if it isn't
        /// set to that value).</remarks>
        public CircleCentering RootCentering
        {
            get { return this.mRootCentering; }
            set
            {
                if (this.mRootCentering != value)
                {
                    this.mRootCentering = value;
                }
            }
        }
        /// <summary>
        /// Gets or sets the minimum length of an edge connecting a
        /// subtree/leaf node to its root node.
        /// </summary>
        public double MinimumEdgeLength
        {
            get { return this.mMinEdgeLen; }
            set
            {
                if (this.mMinEdgeLen != value)
                {
                    this.mMinEdgeLen = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets whether the lengths of distances between a set of
        /// subtree/leaf nodes and their shared root node are equalized or
        /// minimized.</summary>
        public bool EqualizeBranchLengths
        {
            get { return this.bEqualizeBranches; }
            set
            {
                if (this.bEqualizeBranches != value)
                {
                    this.bEqualizeBranches = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary><para>
        /// Gets or sets the maximum allowable wedge in radians that the set
        /// of subtree/leaf nodes are allowed to occupy around the root node
        /// of the entire balloon tree.</para><para>
        /// Be aware that this angle will be normalized to the range [0,2π] 
        /// ( [0°,360°] ) when used.</para></summary><remarks>
        /// If the sum the bounding wedges of the set of subtree/leaf nodes
        /// exceeds this wedge, their <see cref="P:CircleTree`2.Distance"/>s
        /// are increased until all their bounding wedges can fit within it.
        /// Then their <see cref="P:CircleTree`2.Angle"/>s are set in the
        /// range <c>(-wedge / 2, wedge / 2)</c>, measured counterclockwise
        /// from the +X-axis of their shared root's local coordinate system.
        /// </remarks><seealso cref="MaximumTreeWedge"/>
        public double MaximumRootWedge
        {
            get { return this.mMaxRootWedge; }
            set
            {
                if (this.mMaxRootWedge != value)
                {
                    this.mMaxRootWedge = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary><para>
        /// Gets or sets the maximum allowable wedge in radians that a set
        /// of subtree/leaf nodes are allowed to occupy around their 
        /// shared root node.</para><para>
        /// Be aware that this angle will be normalized to the range [0,2π] 
        /// ( [0°,360°] ) when used.</para></summary><remarks>
        /// If the sum the bounding wedges of the set of subtree/leaf nodes
        /// exceeds this wedge, their <see cref="P:CircleTree`2.Distance"/>s
        /// are increased until all their bounding wedges can fit within it.
        /// Then their <see cref="P:CircleTree`2.Angle"/>s are set in the
        /// range <c>(-wedge / 2, wedge / 2)</c>, measured counterclockwise
        /// from the +X-axis of their shared root's local coordinate system.
        /// </remarks><seealso cref="MaximumRootWedge"/>
        public double MaximumTreeWedge
        {
            get { return this.mMaxTreeWedge; }
            set
            {
                if (this.mMaxTreeWedge != value)
                {
                    this.mMaxTreeWedge = value;
                    this.bPositionsDirty = true;
                }
            }
        }

        protected void ForceRecalculateBranchPositions()
        {
            this.bPositionsDirty = true;
        }
        #endregion

        #region Physical Animation Parameters

        public bool AdaptToSizeChanges
        {
            get { return this.bAdaptToSizeChanges; }
            set
            {
                if (this.bAdaptToSizeChanges != value)
                {
                    this.bAdaptToSizeChanges = value;
                }
            }
        }
        /// <summary>
        /// Gets or sets whether the roots of any leaf/subtree nodes with
        /// fixed positions are first repositioned to attempt to set the
        /// local polar coordinate positions of their fixed branches equal
        /// to those calculated for the balloon tree.</summary>
        public bool AdjustRootCenters
        {
            get { return this.bAdjustRoots; }
            set
            {
                if (this.bAdjustRoots != value)
                {
                    this.bAdjustRoots = value;
                }
            }
        }

        public bool AdjustRootAngle
        {
            get { return this.bAdjustAngle; }
            set
            {
                if (this.bAdjustAngle != value)
                {
                    this.bAdjustAngle = value;
                }
            }
        }

        public double SpringMultiplier
        {
            get { return this.mSpringMult; }
            set
            {
                if (this.mSpringMult != value)
                {
                    this.mSpringMult = value;
                }
            }
        }

        public double MagneticMultiplier
        {
            get { return this.mMagnetMult; }
            set
            {
                if (this.mMagnetMult != value)
                {
                    this.mMagnetMult = value;
                }
            }
        }

        public double MagneticExponent
        {
            get { return this.mMagnetExp; }
            set
            {
                if (this.mMagnetExp != value)
                {
                    this.mMagnetExp = value;
                }
            }
        }
        /// <summary>
        /// Gets or sets the angle which the entire balloon tree is rotated
        /// around the center of its root node, measured in radians
        /// counterclockwise from the +X-axis.
        /// </summary><remarks>
        /// Since this angle is measured clockwise from the +X-axis on a
        /// standard drawing surface (because the Y-axis is negated),
        /// the final graph will appear as if it has been rotated by the
        /// negation of this angle on a conventional 2D Euclidean manifold. 
        /// </remarks>
        public double RootAngle
        {
            get { return this.mRootAngle; }
            set
            {
                if (this.mRootAngle != value)
                {
                    this.mRootAngle = value;
                }
            }
        }
        #endregion

        #region Angle Parameters in Degrees
        /// <summary>
        /// Gets or sets the <see cref="MaximumRootWedge"/> parameter of this
        /// layout algorithm in degrees instead of radians for debugging.
        /// </summary>
        public double DegMaxRootWedge
        {
            get { return 180.0 * this.mMaxRootWedge / Math.PI; }
            set
            {
                value = Math.PI * value / 180.0;
                if (this.mMaxRootWedge != value)
                {
                    this.mMaxRootWedge = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets the <see cref="MaximumTreeWedge"/> parameter of this
        /// layout algorithm in degrees instead of radians for debugging.
        /// </summary>
        public double DegMaxTreeWedge
        {
            get { return 180.0 * this.mMaxTreeWedge / Math.PI; }
            set
            {
                value = Math.PI * value / 180.0;
                if (this.mMaxTreeWedge != value)
                {
                    this.mMaxTreeWedge = value;
                    this.bPositionsDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets the <see cref="RootAngle"/> parameter of this
        /// layout algorithm in degrees instead of radians for debugging.
        /// </summary>
        public double DegRootAngle
        {
            get { return 180.0 * this.mRootAngle / Math.PI; }
            set
            {
                value = Math.PI * value / 180.0;
                if (this.mRootAngle != value)
                {
                    this.mRootAngle = value;
                }
            }
        }
        #endregion

        #endregion

        /*protected override void OnRootInserted(int index, 
            Digraph<Node, Edge>.GNode root)
        {
            if (this.mRootFindingMethod == TreeRootFinding.UserDefined)
            {
                this.bCircleTreeDirty = true;
            }
            base.OnRootInserted(index, root);
        }

        protected override void OnRootRemoved(Digraph<Node, Edge>.GNode root)
        {
            if (this.mRootFindingMethod == TreeRootFinding.UserDefined)
            {
                this.bCircleTreeDirty = true;
            }
            base.OnRootRemoved(root);
        }

        protected override void OnRootsCleared()
        {
            if (this.mRootFindingMethod == TreeRootFinding.UserDefined)
            {
                this.bCircleTreeDirty = true;
            }
            base.OnRootsCleared();
        }/* */

        protected override void PerformPrecalculations(
            uint lastNodeVersion, uint lastEdgeVersion)
        {
            /*bool nDirty = this.mGraph.NodeVersion != lastNodeVersion;
            if (this.bSpanTreeDirty || nDirty ||
                this.mGraph.EdgeVersion != lastEdgeVersion)
            {
                this.GenerateSpanningTree();
                this.bCircleTreeDirty = true;
                this.bPositionsDirty = true;
            }
            if (this.bCircleTreeDirty)
            {
                this.mCircleTree = this.BuildBalloonTree();
                this.bPositionsDirty = true;
            }
            if (this.mCircleTree != null && !this.bCircleTreeDirty && 
                this.bAdaptToSizeChanges)
            {
                this.RefreshRadius(this.mCircleTree);
                this.bPositionsDirty |= this.mCircleTree.ConvexHullDirty;
            }
            if (this.mCircleTree != null && this.bPositionsDirty)
            {
                this.CalculatePositions(this.mCircleTree);
            }
            if (this.mCircleTree != null && nDirty)/* */
            if (this.mGraph.NodeVersion != lastNodeVersion)
            {
                int count = 0;
                Digraph<Node, Edge>.GNode gNode;
                // The centroid should not be recalculated on every iteration
                // of the computation, because doing so might cause a "drift"
                // phenomenon in which the graph continuously applies a large
                // force to itself in the direction of the change in position
                // from the old centroid to the new one.
                this.mCX = this.mCY = 0.0;
                for (int i = this.mGraph.NodeCount - 1; i >= 0; i--)
                {
                    gNode = this.mGraph.InternalNodeAt(i);
                    if (!gNode.Hidden)
                    {
                        this.mCX += gNode.Data.X;
                        this.mCY += gNode.Data.Y;
                        count++;
                    }
                }
                this.mCX /= count;
                this.mCY /= count;
            }
            base.PerformPrecalculations(lastNodeVersion, lastEdgeVersion);
            //this.bSpanTreeDirty = false;
            //this.bCircleTreeDirty = false;
            //this.bPositionsDirty = false;
        }

        private void PullOnRoots(
            GTree<Node, Edge, CircleGeom<Node, Edge>> tree)
        {
            // If fixed, adjust angle/distance of ancestors,
            // Else iterate through its branches and recursively check
            // if they are fixed, repeating the process up to leaf nodes

            // Recursive branch iteration is not done for fixed subtrees
            // because the fixation of their branches is irrelevant, 
            // since their fixed branches can't adjust their fixed root.

            Node node = tree.NodeData;
            if (node.PositionFixed)
            {
                double ang, cx, cy, dx, dy, r, force, fx, fy;
                GTree<Node, Edge, CircleGeom<Node, Edge>> ct = tree;
                GTree<Node, Edge, CircleGeom<Node, Edge>> root = ct.Root;
                while (root != null)
                {
                    // Calculate force on root
                    cx = root.NodeData.X;
                    cy = root.NodeData.Y;
                    if (root.Root == null)
                    {
                        ang = this.mRootAngle;
                    }
                    else
                    {
                        node = root.Root.NodeData;
                        ang = Math.Atan2(cy - node.Y, cx - node.X);
                    }
                    node = ct.NodeData;
                    // TODO: make sure all the signs (+/-) are right
                    dx = cx - node.X;
                    dy = cy - node.Y;
                    if (dx == 0 && dy == 0)
                    {
                        fx = fy = ct.GeomData.Distance / 10;
                    }
                    else
                    {
                        
                        if (this.bAdjustAngle && root.Root == null)
                        {
                            this.mRootAngle = Math.Atan2(-dy, -dx) 
                                - ct.GeomData.Angle;
                            while (this.mRootAngle < -Math.PI)
                                this.mRootAngle += 2 * Math.PI;
                            while (this.mRootAngle > Math.PI)
                                this.mRootAngle -= 2 * Math.PI;
                            fx = fy = 0;
                            r = Math.Sqrt(dx * dy + dy * dy);
                        }
                        else
                        {
                            r = dx * dx + dy * dy;
                            // Magnetic Torque
                            force = ct.GeomData.Angle + ang;
                            // dx and dy have to be negated here in
                            // order to get the same results as the 
                            // single step method that uses Cos/Sin
                            force = Math.Atan2(-dy, -dx) - force;
                            while (force < -Math.PI)
                                force += 2 * Math.PI;
                            while (force > Math.PI)
                                force -= 2 * Math.PI;
                            force = this.mMagnetMult *
                                Math.Pow(force, this.mMagnetExp) / r;
                            fx = force * -dy;
                            fy = force * dx;
                            r = Math.Sqrt(r);
                        }
                        // Spring Force
                        force = this.mSpringMult *
                            Math.Log(r / ct.GeomData.Distance);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Apply force to root position
                    node = root.NodeData;
                    node.SetPosition(node.X - (float)fx, 
                                     node.Y - (float)fy);
                    // Progress up the ancestry chain
                    ct = root;
                    root = ct.Root;
                }
            }
            else
            {
                GTree<Node, Edge, CircleGeom<Node, Edge>>[] branches 
                    = tree.Branches;
                for (int i = 0; i < branches.Length; i++)
                {
                    this.PullOnRoots(branches[i]);
                }
            }
        }

        protected override GTree<Node, Edge, CircleGeom<Node, Edge>> CreateTree(
            Digraph<Node, Edge>.GNode node, Edge edge)
        {
            this.bCircleTreeDirty = true;
            CircleGeom<Node, Edge> geom = new CircleGeom<Node, Edge>(
                this.GetBoundingRadius(node.Data, node.Index));
            GTree<Node, Edge, CircleGeom<Node, Edge>> tree
                = new GTree<Node, Edge, CircleGeom<Node, Edge>>(
                    node.Index, node.Data, edge, geom, 
                    node.TotalEdgeCount(false));
            geom.SetOwner(tree);
            return tree;
        }

        protected override void PerformTreePrecalculations(
            GTree<Node, Edge, CircleGeom<Node, Edge>> dataTree, 
            uint lastNodeVersion, uint lastEdgeVersion)
        {
            if (this.bCircleTreeDirty)
            {
                this.bPositionsDirty = true;
            }
            else if (this.bAdaptToSizeChanges)
            {
                this.RefreshRadius(dataTree);
                this.bPositionsDirty |= dataTree.GeomData.ConvexHullDirty;
            }
            if (this.bPositionsDirty)
            {
                this.CalculatePositions(dataTree);
            }
            this.bCircleTreeDirty = false;
            this.bPositionsDirty = false;
        }

        private GTree<Node, Edge, CircleGeom<Node, Edge>>[] mStackQueue
            = new GTree<Node, Edge, CircleGeom<Node, Edge>>[0];
        //private Stack<CircleTree<Node, Edge>> mStack;
        //private Queue<CircleTree<Node, Edge>> mQueue;

        protected override void PerformIteration(uint iteration)
        {
            GTree<Node, Edge, CircleGeom<Node, Edge>> dTree = this.DataTree;
            /*if (this.bCircleTreeDirty)
            {
                this.bPositionsDirty = true;
            }
            else if (this.bAdaptToSizeChanges)
            {
                this.RefreshRadius(dTree);
                this.bPositionsDirty |= dTree.GeomData.ConvexHullDirty;
            }
            if (this.bPositionsDirty)
            {
                this.CalculatePositions(dTree);
            }
            this.bCircleTreeDirty = false;
            this.bPositionsDirty = false;/* */

            int i, sqIndex, sqCount;
            Node node;
            GTree<Node, Edge, CircleGeom<Node, Edge>> ct, root;
            GTree<Node, Edge, CircleGeom<Node, Edge>>[] branches;
            double ang, cx, cy, dx, dy, r, force, fx, fy;

            // Initially set new positions to current positions, since
            // some of them might be adjusted instead of directly set
            /*for (i = this.mGraph.NodeCount - 1; i >= 0; i--)
            {
                node = this.mGraph.NodeAt(i);
                node.SetNewPosition(node.X, node.Y);
            }/* */

            //node = this.mCircleTree.NodeData;
            node = dTree.NodeData;
            if (!node.PositionFixed)
            {
                // Pull the root of the entire balloon tree
                // towards its calculated center.
                Box2F bbox = null;
                double cw, ch;
                cx = cy = cw = ch = 0.0;
                switch (this.mRootCentering)
                {
                    case CircleCentering.BBoxCenter:
                        bbox = this.mClusterNode == null
                            ? this.BoundingBox
                            : this.mClusterNode.LayoutBBox;
                        if (bbox != null)
                        {
                            cx = bbox.X;
                            cy = bbox.Y;
                            cw = bbox.W;
                            ch = bbox.H;
                        }
                        break;
                    case CircleCentering.Centroid:
                        bbox = this.mClusterNode == null
                            ? this.BoundingBox
                            : this.mClusterNode.LayoutBBox;
                        if (bbox != null)
                        {
                            // Calculate a bounding box centered at the
                            // current centroid and enclosed within the
                            // bounding box of this layout algorithm.
                            // TODO: What if the centroid is outside the
                            // bounding box of this layout algorithm?
                            dx = Math.Min(Math.Abs(this.mCX - bbox.X), 
                                          Math.Abs(bbox.Right - this.mCX));
                            dy = Math.Min(Math.Abs(this.mCY - bbox.Y), 
                                          Math.Abs(bbox.Bottom - this.mCY));
                            cx = this.mCX - dx;
                            cy = this.mCY - dy;
                            cw = 2.0 * dx;
                            ch = 2.0 * dy;
                        }
                        break;
                    // No need to calculate for Predefined, as the center 
                    // is the current position of the root node
                }
                if (bbox != null)
                {
                    ang = Math.Sqrt(cw * cw + ch * ch) / 2;
                    fx = fy = 0.0;
                    // Spring Force from Top Left Corner
                    dx = cx - node.X;
                    dy = cy - node.Y;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Spring Force from Top Right Corner
                    dx += cw;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Spring Force from Bottom Right Corner
                    dy += ch;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Spring Force from Bottom Left Corner
                    dx -= cw;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Apply force to root position
                    node.SetPosition(node.X + (float)fx, 
                                     node.Y + (float)fy);
                }
            }
            if (this.mStackQueue.Length < dTree.TreeSize)
            {
                this.mStackQueue = new GTree<Node, Edge, 
                    CircleGeom<Node, Edge>>[dTree.TreeSize];
            }
            if (this.bAdjustRoots)
            {
                // Pull roots towards their fixed branches
                //this.PullOnRoots(this.mCircleTree);
                /*if (this.mStack == null)
                {
                    this.mStack = new Stack<CircleTree<Node, Edge>>(
                        this.mGraph.NodeCount);
                }
                this.mStack.Push(this.mCircleTree);/* */
                sqCount = 1;
                this.mStackQueue[0] = dTree;//this.mCircleTree;
                while (sqCount > 0)//this.mStack.Count > 0)
                {
                    root = this.mStackQueue[--sqCount];//this.mStack.Pop();
                    if (root.NodeData.PositionFixed)
                    {
                        ct = root;
                        root = ct.Root;
                        while (root != null)
                        {
                            // Calculate force on root
                            cx = root.NodeData.X;
                            cy = root.NodeData.Y;
                            if (root.Root == null)
                            {
                                ang = this.mRootAngle;
                            }
                            else
                            {
                                node = root.Root.NodeData;
                                ang = Math.Atan2(cy - node.Y,
                                                 cx - node.X);
                            }
                            node = ct.NodeData;
                            // TODO: make sure all the signs (+/-) are right
                            dx = cx - node.X;
                            dy = cy - node.Y;
                            if (dx == 0 && dy == 0)
                            {
                                fx = fy = ct.GeomData.Distance / 10;
                            }
                            else
                            {
                                if (this.bAdjustAngle && root.Root == null)
                                {
                                    this.mRootAngle = Math.Atan2(-dy, -dx)
                                        - ct.GeomData.Angle;
                                    while (this.mRootAngle < -Math.PI)
                                        this.mRootAngle += 2 * Math.PI;
                                    while (this.mRootAngle > Math.PI)
                                        this.mRootAngle -= 2 * Math.PI;
                                    fx = fy = 0;
                                    r = Math.Sqrt(dx * dx + dy * dy);
                                }
                                else
                                {
                                    r = dx * dx + dy * dy;
                                    // Magnetic Torque
                                    force = ct.GeomData.Angle + ang;
                                    // dx and dy have to be negated here in
                                    // order to get the same results as the 
                                    // single step method that uses Cos/Sin
                                    force = Math.Atan2(-dy, -dx) - force;
                                    while (force < -Math.PI)
                                        force += 2 * Math.PI;
                                    while (force > Math.PI)
                                        force -= 2 * Math.PI;
                                    force = this.mMagnetMult *
                                        Math.Pow(force, this.mMagnetExp) / r;
                                    fx = force * -dy;
                                    fy = force * dx;
                                    r = Math.Sqrt(r);
                                }
                                // Spring Force
                                force = this.mSpringMult *
                                    Math.Log(r / ct.GeomData.Distance);
                                fx += force * dx / r;
                                fy += force * dy / r;
                            }
                            // Apply force to root position
                            node = root.NodeData;
                            node.SetPosition(node.X - (float)fx,
                                             node.Y - (float)fy);
                            // Progress up the ancestry chain
                            ct = root;
                            root = ct.Root;
                        }
                    }
                    else
                    {
                        branches = root.Branches;
                        for (i = branches.Length - 1; i >= 0; i--)
                        {
                            //this.mStack.Push(branches[i]);
                            this.mStackQueue[sqCount++] = branches[i];
                        }
                    }
                }/* */
            }
            // Pull movable branches towards their roots
            /*if (this.mQueue == null)
            {
                this.mQueue = new Queue<CircleTree<Node, Edge>>(
                    this.mGraph.NodeCount);
            }
            this.mQueue.Enqueue(this.mCircleTree);/* */
            sqIndex = 0;
            sqCount = 1;
            this.mStackQueue[0] = dTree;//this.mCircleTree;
            while (sqIndex < sqCount)//this.mQueue.Count > 0)
            {
                ct = this.mStackQueue[sqIndex++];//this.mQueue.Dequeue();
                cx = ct.NodeData.X;
                cy = ct.NodeData.Y;
                if (ct.Root == null)
                {
                    ang = this.mRootAngle;
                }
                else
                {
                    node = ct.Root.NodeData;
                    ang = Math.Atan2(cy - node.Y, cx - node.X);
                }
                branches = ct.Branches;
                for (i = 0; i < branches.Length; i++)
                {
                    ct = branches[i];
                    node = ct.NodeData;
                    if (!node.PositionFixed)
                    {
                        // TODO: make sure all the signs (+/-) are right
                        fx = node.X;
                        fy = node.Y;
                        dx = cx - fx;
                        dy = cy - fy;
                        if (dx == 0 && dy == 0)
                        {
                            force = ct.GeomData.Distance / 10;
                            fx += force;
                            fy += force;
                        }
                        else
                        {
                            r = dx * dx + dy * dy;
                            // Magnetic Torque
                            force = ct.GeomData.Angle + ang;
                            // dx and dy have to be negated here in
                            // order to get the same results as the 
                            // single step method that uses Cos/Sin
                            force = Math.Atan2(-dy, -dx) - force;
                            while (force < -Math.PI)
                                force += 2 * Math.PI;
                            while (force > Math.PI)
                                force -= 2 * Math.PI;
                            force = this.mMagnetMult * 
                                Math.Pow(force, this.mMagnetExp) / r;
                            fx += force * -dy;
                            fy += force * dx;
                            // Spring Force
                            r = Math.Sqrt(r);
                            force = this.mSpringMult * 
                                Math.Log(r / ct.GeomData.Distance);
                            fx += force * dx / r;
                            fy += force * dy / r;
                        }
                        // Add force to position
                        node.SetPosition((float)fx, (float)fy);/* */

                        /*dx = cx + ct.Distance * Math.Cos(ct.Angle + ang);
                        dy = cy + ct.Distance * Math.Sin(ct.Angle + ang);
                        node.SetNewPosition((float)dx, (float)dy);/* */
                    }
                    //this.mQueue.Enqueue(ct);
                    this.mStackQueue[sqCount++] = ct;
                }
            }
        }

        /*private void GenerateSpanningTree()
        {
            ISpanningTreeAlgorithm<Node, Edge> alg = null;
            switch (this.mSpanTreeGen)
            {
                case SpanningTreeGen.BFS:
                    BFSpanningTree<Node, Edge> bfst
                        = new BFSpanningTree<Node, Edge>(
                            this.mGraph, false, false);
                    bfst.RootCapacity = this.RootCount;
                    Digraph<Node, Edge>.GNode r1;
                    for (int i = this.RootCount - 1; i >= 0; i--)
                    {
                        r1 = this.RootAt(i);
                        bfst.AddRoot(r1.Index);
                    }
                    alg = bfst;
                    break;
                case SpanningTreeGen.DFS:
                    DFSpanningTree<Node, Edge> dfst
                        = new DFSpanningTree<Node, Edge>(
                            this.mGraph, false, false);
                    dfst.RootCapacity = this.RootCount;
                    Digraph<Node, Edge>.GNode r2;
                    for (int j = this.RootCount - 1; j >= 0; j--)
                    {
                        r2 = this.RootAt(j);
                        dfst.AddRoot(r2.Index);
                    }
                    alg = dfst;
                    break;
                case SpanningTreeGen.Boruvka:
                    alg = new BoruvkaMinSpanningTree<Node, Edge>(mGraph);
                    break;
                case SpanningTreeGen.Kruskal:
                    alg = new KruskalMinSpanningTree<Node, Edge>(mGraph);
                    break;
                case SpanningTreeGen.Prim:
                    alg = new PrimMinSpanningTree<Node, Edge>(mGraph);
                    break;
            }
            alg.Compute();
            this.mSpanTree = alg.SpanningTree;
        }

        private CircleTree<Node, Edge> BuildBalloonTree()
        {
            this.mTreeSize = 0;
            if (this.mSpanTree.NodeCount == 0 ||
                this.mSpanTree.EdgeCount == 0)
            {
                return null;
            }
            int i, rootIndex;
            Digraph<Node, Edge>.GNode root = null;
            int count = this.mGraph.NodeCount;
            for (i = 0; i < count; i++)
            {
                root = this.mGraph.InternalNodeAt(i);
                //root.Index = i;
                root.Color = GraphColor.White;
            }
            switch (this.mRootFindingMethod)
            {
                case TreeRootFinding.UserDefined:
                    if (this.RootCount == 0)
                    {
                        rootIndex = 0;
                        root = this.mSpanTree.InternalNodeAt(0);
                    }
                    else
                    {
                        root = this.RootAt(0);
                        rootIndex = root.Index;
                        root = this.mSpanTree.InternalNodeAt(rootIndex);
                    }
                    break;
                case TreeRootFinding.Center:
                    root = this.mSpanTree.FindCenter(true, false);
                    if (root == null)
                    {
                        root = this.mSpanTree.InternalNodeAt(0);
                        rootIndex = 0;
                    }
                    else
                    {
                        rootIndex = root.Index;
                    }
                    break;
                case TreeRootFinding.PathCenter:
                    root = this.mSpanTree.FindPathCenter();
                    if (root == null)
                    {
                        root = this.mSpanTree.InternalNodeAt(0);
                        rootIndex = 0;
                    }
                    else
                    {
                        rootIndex = root.Index;
                    }
                    break;
            }
            return this.BuildBranch(root, default(Edge));
        }

        private CircleTree<Node, Edge> BuildBranch(
            Digraph<Node, Edge>.GNode root, Edge edge)
        {
            this.mTreeSize++;
            root.Color = GraphColor.Gray;

            CircleTree<Node, Edge> child, parent 
                = new CircleTree<Node, Edge>(root.Data, edge, 
                    this.GetBoundingRadius(root.Data), 
                    root.TotalEdgeCount(false));

            // Recursively add child branches.
            int i, eCount = this.mSpanTree.EdgeCount;
            Digraph<Node, Edge>.GEdge gEdge;
            Digraph<Node, Edge>.GNode gNode;

            for (i = 0; i < eCount; i++)
            {
                gEdge = this.mSpanTree.InternalEdgeAt(i);
                if (gEdge.SrcNode.Index == root.Index)
                {
                    gNode = gEdge.DstNode;
                    if (gNode.Color == GraphColor.White)
                    {
                        child = this.BuildBranch(gNode, gEdge.Data);
                        child.SetRoot(parent);
                    }
                }
                else if (gEdge.DstNode.Index == root.Index)
                {
                    gNode = gEdge.SrcNode;
                    if (gNode.Color == GraphColor.White)
                    {
                        child = this.BuildBranch(gNode, gEdge.Data);
                        child.SetRoot(parent);
                    }
                }
            }
            root.Color = GraphColor.Black;

            return parent;
        }/* */

        private void RefreshRadius(
            GTree<Node, Edge, CircleGeom<Node, Edge>> root)
        {
            if (root.BranchCount > 0)
            {
                GTree<Node, Edge, CircleGeom<Node, Edge>>[] branches 
                    = root.Branches;
                for (int i = branches.Length - 1; i >= 0; i--)
                {
                    this.RefreshRadius(branches[i]);
                }
            }
            root.GeomData.Radius 
                = this.GetBoundingRadius(root.NodeData, root.NodeIndex);
        }

        /// <summary>
        /// Calculates the radius of a circle that encloses the given
        /// <paramref name="node"/>, which is used to calculate the convex
        /// hulls of the subtrees that include the given node in their
        /// branches.</summary>
        /// <param name="node">The node enclosed within a circle of the
        /// returned radius.</param>
        /// <param name="nodeIndex">The index of the <paramref name="node"/>
        /// in its graph, which is being processed by this layout algorithm.
        /// </param>
        /// <returns>The radius of the bounding circle of the given
        /// <paramref name="node"/>, which by default is the smallest circle
        /// that circumscribes the given node's bounding box.</returns>
        /// <remarks><para>
        /// This function is only used when the layout algorithm builds its
        /// balloon tree data structure, which is only done when its 
        /// <see cref="P:LayoutAlgorithm`2.Graph"/> and/or the values of its
        /// <see cref="SpanningTreeGeneration"/> and/or 
        /// <see cref="RootFindingMethod"/> parameters are changed.
        /// </para><para>
        /// By default, this function simply returns half the length of the
        /// diagonal of the given <paramref name="node"/>'s 
        /// <see cref="ILayoutNode.LayoutBBox"/>, which is the radius of the
        /// smallest circle that circumscribes it.  It does not compensate
        /// for the possibility that the node's "center" might not be the
        /// center of its bounding box (the box's <see cref="Box2F.X"/>
        /// might not be equal to <c>-<see cref="Box2F.W"/> / 2</c>, or its
        /// <see cref="Box2F.Y"/> might not be equal to 
        /// <c>-<see cref="Box2F.H"/> / 2</c>).</para><para>
        /// This method can be overridden to take that into account, and/or
        /// to provide a more efficient bounding radius calculation for
        /// certain nodes. However, be aware that if this function ever
        /// returns a value less than or equal to zero, an
        /// <see cref="ArgumentOutOfRangeException"/> will be thrown when
        /// the layout algorithm attempts to use that invalid radius.
        /// </para></remarks>
        protected virtual double GetBoundingRadius(Node node, int nodeIndex)
        {
            Box2F bbox = node.LayoutBBox;
            return Math.Sqrt(bbox.W * bbox.W + bbox.H * bbox.H) / 2;
        }

        private void CalculatePositions(
            GTree<Node, Edge, CircleGeom<Node, Edge>> root)
        {
            if (root.BranchCount == 0)
            {
                root.GeomData.CalculateConvexHull();
            }
            else
            {
                GTree<Node, Edge, CircleGeom<Node, Edge>>[] branches 
                    = root.Branches;
                for (int i = 0; i < branches.Length; i++)
                {
                    this.CalculatePositions(branches[i]);
                }
                this.CalculateBranchPositions(branches);
                root.GeomData.CalculateConvexHull();
            }
        }

        /// <summary>
        /// Calculates the polar coordinates (the 
        /// <see cref="P:CircleTree`2{Node,Edge}.Angle"/> and 
        /// <see cref="P:CircleTree`2{Node,Edge}.Distance"/>) of each
        /// subtree or leaves in the given array of 
        /// <paramref name="branches"/>.</summary>
        /// <param name="branches">An array of layout node subtrees or leaves
        /// that share the same <see cref="P:CircleTree`2{Node,Edge}.Root"/>.
        /// </param><remarks><para>
        /// For classes that reimplement this function, be aware that this
        /// function is invoked recursively from the root down to the leaves
        /// of the layout tree, so the polar coordinates of the positions of 
        /// the <see cref="P:CircleTree`2{Node,Edge}.Branches"/> of each 
        /// subtree in the given <paramref name="branches"/> have already 
        /// been calculated by a previous invocation of this function, and 
        /// then the <see cref="P:CircleTree`2{Node,Edge}.ConvexHull"/> of 
        /// each subtree was calculated based on those positions.
        /// </para><para>
        /// In general, take great care when reimplementing this function, as
        /// it is the most important function of the entire balloon tree
        /// layout algorithm. The polar coordinate positions of the given
        /// <paramref name="branches"/> calculated by this function are not 
        /// only used to calculate the convex hull of their shared
        /// <see cref="P:CircleTree`2{Node,Edge}.Root"/>, but they are also 
        /// used to determine the final positions of the layout nodes at 
        /// their centers.</para></remarks>
        protected virtual void CalculateBranchPositions(
            GTree<Node, Edge, CircleGeom<Node, Edge>>[] branches)
        {
            int i, j;
            // Set the initial distance of each branch based on MinEdgeLen
            Box2F bbox;
            CircleGeom<Node, Edge> ct;
            double rootRad = branches[0].Root.GeomData.Radius 
                           + this.mMinEdgeLen;
            double maxDist = -double.MaxValue;
            for (i = 0; i < branches.Length; i++)
            {
                ct = branches[i].GeomData;
                bbox = ct.CalculateBoundingBox();
                ct.Distance = rootRad - bbox.X;
                if (ct.Distance > maxDist)
                    maxDist = ct.Distance;
            }
            // Calculate the initial bounding wedges of the branches
            if (this.bEqualizeBranches)
            {
                for (i = 0; i < branches.Length; i++)
                {
                    ct = branches[i].GeomData;
                    ct.Distance = maxDist;
                    ct.CalculateBoundingWedge();
                }
            }
            else
            {
                for (i = 0; i < branches.Length; i++)
                {
                    branches[i].GeomData.CalculateBoundingWedge();
                }
            }
            // Sort the branches to their final order counterclockwise
            // around their root starting at -pi (-180 degrees).
            this.SortBranches(branches);
            // Get the maximum allowable wedge that the branches can occupy
            double maxWedge = this.GetMaximumTreeWedge(branches[0].Root);
            while (maxWedge < 0.0)
                maxWedge += 2 * Math.PI;
            while (maxWedge > 2 * Math.PI)
                maxWedge -= 2 * Math.PI;
            // Set the final polar coordinate positions of the branches
            double wedge, ratio;
            switch (this.mBranchSpacing)
            {
                case CircleSpacing.Fractal:
                    double a;
                    // Calculate the final distances of the branches
                    wedge = maxWedge / (2 * branches.Length);
                    ratio = Math.Sin(wedge);
                    for (i = 0; i < branches.Length; i++)
                    {
                        ct = branches[i].GeomData;
                        a = Math.Max(ct.LowerWedge, ct.UpperWedge);
                        //while (a > wedge)
                        for (j = 0; j < 50 && a > wedge; j++)
                        {
                            ct.Distance = ct.Distance * Math.Sin(a) / ratio;
                            ct.CalculateBoundingWedge();
                            a = Math.Max(ct.LowerWedge, ct.UpperWedge);
                        }
                        if (ct.Distance > maxDist)
                            maxDist = ct.Distance;
                    }
                    if (this.bEqualizeBranches)
                    {
                        for (i = 0; i < branches.Length; i++)
                        {
                            branches[i].GeomData.Distance = maxDist;
                        }
                    }
                    // Calculate the final angles of the branches
                    a = maxWedge / -2.0;
                    for (i = 0; i < branches.Length; i++)
                    {
                        a += wedge;
                        branches[i].GeomData.Angle = a;
                        a += wedge;
                    }
                    break;
                case CircleSpacing.SNS:
                    // Calculate the final distances of the branches
                    wedge = 0.0;
                    for (i = 0; i < branches.Length; i++)
                    {
                        ct = branches[i].GeomData;
                        wedge += ct.LowerWedge + ct.UpperWedge;
                    }
                    //while (wedge > maxWedge)
                    for (j = 0; j < 50 && wedge > maxWedge; j++)
                    {
                        ratio = wedge / maxWedge;
                        wedge = 0.0;
                        for (i = 0; i < branches.Length; i++)
                        {
                            ct = branches[i].GeomData;
                            ct.Distance = ct.Distance * ratio;
                            ct.CalculateBoundingWedge();
                            wedge += ct.LowerWedge + ct.UpperWedge;
                        }
                    }
                    // Calculate the final angles of the branches
                    ratio = (maxWedge - wedge) / (2 * branches.Length);
                    wedge = maxWedge / -2.0;
                    for (i = 0; i < branches.Length; i++)
                    {
                        ct = branches[i].GeomData;
                        wedge += ct.LowerWedge + ratio;
                        ct.Angle = wedge;
                        wedge += ct.UpperWedge + ratio;
                    }
                    break;
            }
        }

        /// <summary><para>
        /// Gets the maximum allowable wedge in radians that the
        /// <see cref="P:CircleTree`2{Node,Edge}.Branches"/> of the given 
        /// <paramref name="root"/> can occupy around it.</para><para>
        /// Be aware that this angle will be normalized to the range [0,2π] 
        /// ( [0°,360°] ) when used.</para></summary>
        /// <param name="root">The root to get maximum allowable wedge that
        /// its branches can occupy around it.</param>
        /// <returns>The maximum allowable wedge in radians that the branches
        /// of the given <paramref name="root"/> can occupy around it.
        /// </returns><remarks>
        /// By default, this function simply returns 
        /// <see cref="MaximumRootWedge"/> for the root of the entire balloon
        /// tree and <see cref="MaximumTreeWedge"/> for the roots of every
        /// subtree in the balloon tree, except when the subtree has exactly
        /// two branches. In that case it returns π (180°) if 
        /// <see cref="MaximumTreeWedge"/> is greater than that amount (when
        /// normalized) in order to make the tree look better. 
        /// See those properties for further details on what the 
        /// <see cref="M:CalculateBranchPositions(CircleTree`2[])"/>
        /// function does with the wedge angle this function returns.
        /// </remarks><seealso cref="MaximumRootWedge"/>
        /// <seealso cref="MaximumTreeWedge"/>
        protected virtual double GetMaximumTreeWedge(
            GTree<Node, Edge, CircleGeom<Node, Edge>> root)
        {
            if (root.Root == null)
                return this.mMaxRootWedge;
            if (root.BranchCount == 2)
            {
                double ang = this.mMaxTreeWedge;
                while (ang < 0.0)
                    ang += 2 * Math.PI;
                while (ang > 2 * Math.PI)
                    ang -= 2 * Math.PI;
                return Math.Min(Math.PI, ang);
            }
            return this.mMaxTreeWedge;
        }

        /// <summary>
        /// This comparer sorts subtree/leaf nodes by their angles in radians
        /// around their shared root node, measured counterclockwise from the
        /// +X-axis using <c>Atan2(leaf.Y - <see cref="SketchSorter.CX"/>,
        /// leaf.X - <see cref="SketchSorter.CY"/>)</c>.
        /// </summary><remarks>
        /// This comparer is provided for any descendant balloon tree layout
        /// algorithms that reimplement the 
        /// <see cref="M:SortBranches(CircleTree`2{Node,Edge}[])"/> function 
        /// and still support <see cref="InSketchMode"/> property.
        /// Anything that uses this comparer should give meaningful values to
        /// its <see cref="SketchSorter.CX"/>, <see cref="SketchSorter.CY"/>,
        /// and <see cref="SketchSorter.RootAngle"/> fields before using it
        /// to sort of a set of <see cref="T:CircleTree`2{Node,Edge}"/>
        /// instances that share the same 
        /// <see cref="P:CircleTree`2{Node,Edge}.Root"/>.</remarks>
        public class SketchSorter 
            : IComparer<GTree<Node, Edge, CircleGeom<Node, Edge>>>
        {
            /// <summary>
            /// The X-coordinate of the center of the shared root of x and y.
            /// </summary>
            public double CX = 0;
            /// <summary>
            /// The Y-coordinate of the center of the shared root of x and y.
            /// </summary>
            public double CY = 0;
            /// <summary><para>
            /// The angle in radians measured counterclockwise from the 
            /// +X-axis of the ray from the center of the shared root of 
            /// x and y to the center of its own root,</para><para>which  
            /// basically represents the direction of the -X-axis of the
            /// local coordinate system of the shared root of x and y.
            /// </para><para>
            /// This is used to make sure that x and y are on the same side
            /// of the -X-axis of the local coordinate system of their shared
            /// root so that they are correctly compared.
            /// </para><para>
            /// If the shared root of x and y has no root of its own (it is
            /// the base root of the entire balloon tree), -π (-180°) should
            /// be used in order to reduce the number of normalization
            /// operations performed on the angles of x and y.
            /// </para></summary>
            public double RootAngle = -Math.PI;

            private double xAng, yAng;
            /// <summary>
            /// Compares the two given subtree/leaf nodes based their current
            /// angles (measured counterclockwise from the +X-axis) around
            /// their shared <see cref="P:CircleTree`2.Root"/>.</summary>
            /// <param name="x">A node to compare by angle.</param>
            /// <param name="y">A node to compare by angle.</param>
            /// <returns>0 if <paramref name="x"/> and <paramref name="y"/>
            /// are at the same angle around their root; 1 if 
            /// <paramref name="x"/> is at a greater angle than 
            /// <paramref name="y"/>; -1 if <paramref name="x"/> is at a
            /// lesser angle than <paramref name="y"/>.</returns>
            public int Compare(GTree<Node, Edge, CircleGeom<Node, Edge>> x, 
                               GTree<Node, Edge, CircleGeom<Node, Edge>> y)
            {
                xAng = Math.Atan2(x.NodeData.Y - this.CY, 
                                  x.NodeData.X - this.CX);
                if (xAng < this.RootAngle)
                    xAng += 2 * Math.PI;
                yAng = Math.Atan2(y.NodeData.Y - this.CY, 
                                  y.NodeData.X - this.CX);
                if (yAng < this.RootAngle)
                    yAng += 2 * Math.PI;
                return xAng == yAng ? 0 : (xAng < yAng ? -1 : 1);
            }
        }
        private SketchSorter mSketchSorter;

        /// <summary><para>
        /// Used by <see cref="M:CalculateBranchPositions(CircleTree`2[])"/>
        /// to sort the given <paramref name="branches"/> in the order in
        /// which they will be arranged counterclockwise around their shared
        /// root from -π (-180°) to π (180°). </para><para>
        /// This ordering is then used to calculate the polar coordinates of 
        /// the position of each subtree or leaf in 
        /// <paramref name="branches"/>.</para></summary>
        /// <param name="branches">An array of layout node subtrees or leaves
        /// that share the same <see cref="P:CircleTree`2{Node,Edge}.Root"/>.
        /// </param><remarks>
        /// Be aware that if this function is reimplemented, it will make
        /// <see cref="InSketchMode"/> and <see cref="BranchSorter"/>
        /// meaningless, unless the reimplementation uses their values.
        /// </remarks>
        protected virtual void SortBranches(
            GTree<Node, Edge, CircleGeom<Node, Edge>>[] branches)
        {
            if (this.bInSketchMode)
            {
                if (this.mSketchSorter == null)
                    this.mSketchSorter = new SketchSorter();
                GTree<Node, Edge, CircleGeom<Node, Edge>> root 
                    = branches[0].Root;
                this.mSketchSorter.CX = root.NodeData.X;
                this.mSketchSorter.CY = root.NodeData.Y;
                if (root.Root == null)
                {
                    this.mSketchSorter.RootAngle = -Math.PI;
                }
                else
                {
                    this.mSketchSorter.RootAngle = Math.Atan2(
                        root.Root.NodeData.Y - this.mSketchSorter.CY,
                        root.Root.NodeData.X - this.mSketchSorter.CX);
                }
                Array.Sort(branches, 0, 
                    branches.Length, this.mSketchSorter);
            }
            else if (this.mBranchSorter != null)
            {
                Array.Sort(branches, 0, 
                    branches.Length, this.mBranchSorter);
            }
        }
    }
}
