using System;
using System.Collections.Generic;
using System.Text;
using GraphForms.Algorithms.Collections;
using GraphForms.Algorithms.Layout.Circular;
using GraphForms.Algorithms.SpanningTree;

namespace GraphForms.Algorithms.Layout.Tree
{
    public class BalloonTreeLayoutAlgorithm<Node, Edge>
        : LayoutAlgorithm<Node, Edge>
        where Node : class, ILayoutNode
        where Edge : IGraphEdge<Node>, IUpdateable
    {
        // Balloon Tree Generating Parameters
        private SpanningTreeGen mSpanTreeGen = SpanningTreeGen.DFS;
        private TreeRootFinding mRootFindingMethod = TreeRootFinding.Center;

        // Sorting Parameters
        private bool bInSketchMode = false;
        private IComparer<CircleTree<Node, Edge>> mBranchSorter = null;

        // Position Calculation Paramaters
        private CircleSpacing mBranchSpacing = CircleSpacing.SNS;
        private CircleCentering mRootCentering = CircleCentering.Predefined;
        private double mMinEdgeLen = 10.0;
        private bool bEqualizeBranches = true;
        private double mMaxRootWedge = 2 * Math.PI;
        private double mMaxTreeWedge = Math.PI * 350.0 / 180.0;

        // Physical Animation Parameters
        private bool bAdjustRoots = true;
        private bool bAdjustAngle = false;
        private double mSpringMult = 10;
        private double mMagnetMult = 100;
        private double mMagnetExp = 1;
        private double mRootAngle = 0;

        // Flags and Calculated Values
        private Digraph<Node, Edge> mSpanTree;
        private Digraph<Node, Edge>.GEdge[] mSpanTreeEdges;
        private CircleTree<Node, Edge> mCircleTree;
        private bool bSpanTreeDirty = true;
        private bool bCircleTreeDirty = true;
        private bool bCenterDirty = true;
        private double mCX;
        private double mCY;

        public BalloonTreeLayoutAlgorithm(Digraph<Node, Edge> graph,
            IClusterNode clusterNode)
            : base(graph, clusterNode)
        {
        }

        public BalloonTreeLayoutAlgorithm(Digraph<Node, Edge> graph,
            Box2F boundingBox)
            : base(graph, boundingBox)
        {
        }

        /// <summary>
        /// Gets the balloon tree data structure generated by this layout  
        /// algorithm based on <see cref="SpanningTreeGeneration"/> and 
        /// <see cref="RootFindingMethod"/> (or null if it hasn't been
        /// generated yet).</summary>
        protected CircleTree<Node, Edge> BalloonTree
        {
            get { return this.mCircleTree; }
        }

        #region Parameters

        #region Balloon Tree Generating Parameters
        /// <summary>
        /// Gets or sets the method this algorithm uses to build its internal
        /// sparsely connected spanning tree for traversing its graph.
        /// </summary>
        public SpanningTreeGen SpanningTreeGeneration
        {
            get { return this.mSpanTreeGen; }
            set
            {
                if (this.mSpanTreeGen != value)
                {
                    this.mSpanTreeGen = value;
                    this.bSpanTreeDirty = true;
                    this.bCircleTreeDirty = true;
                    this.MarkDirty();
                }
            }
        }
        /// <summary>
        /// Gets or sets the method this algorithm uses to choose the root
        /// node from which all subtrees branch off and orbit around.
        /// </summary>
        public TreeRootFinding RootFindingMethod
        {
            get { return this.mRootFindingMethod; }
            set
            {
                if (this.mRootFindingMethod != value)
                {
                    this.mRootFindingMethod = value;
                    this.bCircleTreeDirty = true;
                    this.MarkDirty();
                }
            }
        }
        #endregion

        #region Sorting Parameters
        /// <summary>
        /// Gets or sets whether this balloon tree layout algorithm is in
        /// "sketch mode", in which it arranges subtree/leaf nodes around
        /// their respective root nodes based on their original positions
        /// relative to their roots (in other words, from the original
        /// "sketch" of the graph before this layout algorithm was applied
        /// to it).</summary><remarks>
        /// Be aware that if this mode is enabled, this will supersede
        /// <see cref="BranchSorter"/> and it will be used instead to 
        /// arrange subtrees/leaves around their roots.</remarks>
        public bool InSketchMode
        {
            get { return this.bInSketchMode; }
            set
            {
                if (this.bInSketchMode != value)
                {
                    this.bInSketchMode = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary>
        /// Gets or sets the comparer used to sort subtrees/leaves in the
        /// order in which they will be arranged counterclockwise around
        /// their root from -π (-180°) to π (180°).
        /// </summary><remarks>
        /// Be aware that this is superseded by <see cref="InSketchMode"/>
        /// and won't be used if "sketch mode" is enabled.</remarks>
        public IComparer<CircleTree<Node, Edge>> BranchSorter
        {
            get { return this.mBranchSorter; }
            set
            {
                if (this.mBranchSorter != value)
                {
                    this.mBranchSorter = value;
                    this.MarkDirty();
                }
            }
        }
        #endregion

        #region Position Calculation Parameters
        /// <summary>
        /// Gets or sets the method this algorithm uses to calculate the
        /// angles between subtrees/leaves around their root.
        /// </summary><remarks>
        /// If set to <see cref="CircleSpacing.SNS"/>, the angle computation 
        /// will use the subtree's/leaf's bounding wedge defined by its 
        /// <see cref="P:CircleTree`2.UpperWedge"/> and 
        /// <see cref="P:CircleTree`2.LowerWedge"/> properties
        /// calculated by <see cref="M:CircleTree`2.CalculateAngles()"/>.
        /// </remarks>
        public CircleSpacing BranchSpacing
        {
            get { return this.mBranchSpacing; }
            set
            {
                if (this.mBranchSpacing != value)
                {
                    this.mBranchSpacing = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary>
        /// Gets or sets the method that this algorithm uses to calculate
        /// the initial position of the root of the entire balloon tree.
        /// </summary><remarks>
        /// Be aware that if the position of the root node of the entire 
        /// balloon tree is fixed,
        /// this value is irrelevant (or basically equivalent to 
        /// <see cref="CircleCentering.Predefined"/>, even if it isn't
        /// set to that value).</remarks>
        public CircleCentering RootCentering
        {
            get { return this.mRootCentering; }
            set
            {
                if (this.mRootCentering != value)
                {
                    this.mRootCentering = value;
                    this.bCenterDirty = true;
                }
            }
        }
        /// <summary>
        /// Gets or sets the minimum length of an edge connecting a
        /// subtree/leaf node to its root node.
        /// </summary>
        public double MinimumEdgeLength
        {
            get { return this.mMinEdgeLen; }
            set
            {
                if (this.mMinEdgeLen != value)
                {
                    this.mMinEdgeLen = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary>
        /// Gets or sets whether the lengths of distances between a set of
        /// subtree/leaf nodes and their shared root node are equalized or
        /// minimized.</summary>
        public bool EqualizeBranchLengths
        {
            get { return this.bEqualizeBranches; }
            set
            {
                if (this.bEqualizeBranches != value)
                {
                    this.bEqualizeBranches = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary><para>
        /// Gets or sets the maximum allowable wedge in radians that the set
        /// of subtree/leaf nodes are allowed to occupy around the root node
        /// of the entire balloon tree.</para><para>
        /// Be aware that this angle will be normalized to the range [0,2π] 
        /// ( [0°,360°] ) when used.</para></summary><remarks>
        /// If the sum the bounding wedges of the set of subtree/leaf nodes
        /// exceeds this wedge, their <see cref="P:CircleTree`2.Distance"/>s
        /// are increased until all their bounding wedges can fit within it.
        /// Then their <see cref="P:CircleTree`2.Angle"/>s are set in the
        /// range <c>(-wedge / 2, wedge / 2)</c>, measured counterclockwise
        /// from the +X-axis of their shared root's local coordinate system.
        /// </remarks><seealso cref="MaximumTreeWedge"/>
        public double MaximumRootWedge
        {
            get { return this.mMaxRootWedge; }
            set
            {
                if (this.mMaxRootWedge != value)
                {
                    this.mMaxRootWedge = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary><para>
        /// Gets or sets the maximum allowable wedge in radians that a set
        /// of subtree/leaf nodes are allowed to occupy around their 
        /// shared root node.</para><para>
        /// Be aware that this angle will be normalized to the range [0,2π] 
        /// ( [0°,360°] ) when used.</para></summary><remarks>
        /// If the sum the bounding wedges of the set of subtree/leaf nodes
        /// exceeds this wedge, their <see cref="P:CircleTree`2.Distance"/>s
        /// are increased until all their bounding wedges can fit within it.
        /// Then their <see cref="P:CircleTree`2.Angle"/>s are set in the
        /// range <c>(-wedge / 2, wedge / 2)</c>, measured counterclockwise
        /// from the +X-axis of their shared root's local coordinate system.
        /// </remarks><seealso cref="MaximumRootWedge"/>
        public double MaximumTreeWedge
        {
            get { return this.mMaxTreeWedge; }
            set
            {
                if (this.mMaxTreeWedge != value)
                {
                    this.mMaxTreeWedge = value;
                    this.MarkDirty();
                }
            }
        }
        #endregion

        #region Physical Animation Parameters
        /// <summary>
        /// Gets or sets whether the roots of any leaf/subtree nodes with
        /// fixed positions are first repositioned to attempt to set the
        /// local polar coordinate positions of their fixed branches equal
        /// to those calculated for the balloon tree.</summary>
        public bool AdjustRootCenters
        {
            get { return this.bAdjustRoots; }
            set
            {
                if (this.bAdjustRoots != value)
                {
                    this.bAdjustRoots = value;
                }
            }
        }

        public bool AdjustRootAngle
        {
            get { return this.bAdjustAngle; }
            set
            {
                if (this.bAdjustAngle != value)
                {
                    this.bAdjustAngle = value;
                }
            }
        }

        public double SpringMultiplier
        {
            get { return this.mSpringMult; }
            set
            {
                if (this.mSpringMult != value)
                {
                    this.mSpringMult = value;
                }
            }
        }

        public double MagneticMultiplier
        {
            get { return this.mMagnetMult; }
            set
            {
                if (this.mMagnetMult != value)
                {
                    this.mMagnetMult = value;
                }
            }
        }

        public double MagneticExponent
        {
            get { return this.mMagnetExp; }
            set
            {
                if (this.mMagnetExp != value)
                {
                    this.mMagnetExp = value;
                }
            }
        }
        /// <summary>
        /// Gets or sets the angle which the entire balloon tree is rotated
        /// around the center of its root node, measured in radians
        /// counterclockwise from the +X-axis.
        /// </summary><remarks>
        /// Since this angle is measured clockwise from the +X-axis on a
        /// standard drawing surface (because the Y-axis is negated),
        /// the final graph will appear as if it has been rotated by the
        /// negation of this angle on a conventional 2D Euclidean manifold. 
        /// </remarks>
        public double RootAngle
        {
            get { return this.mRootAngle; }
            set
            {
                if (this.mRootAngle != value)
                {
                    this.mRootAngle = value;
                }
            }
        }
        #endregion

        #region Angle Parameters in Degrees
        /// <summary>
        /// Gets or sets the <see cref="MaximumRootWedge"/> parameter of this
        /// layout algorithm in degrees instead of radians for debugging.
        /// </summary>
        public double DegMaxRootWedge
        {
            get { return 180.0 * this.mMaxRootWedge / Math.PI; }
            set
            {
                value = Math.PI * value / 180.0;
                if (this.mMaxRootWedge != value)
                {
                    this.mMaxRootWedge = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary>
        /// Gets or sets the <see cref="MaximumTreeWedge"/> parameter of this
        /// layout algorithm in degrees instead of radians for debugging.
        /// </summary>
        public double DegMaxTreeWedge
        {
            get { return 180.0 * this.mMaxTreeWedge / Math.PI; }
            set
            {
                value = Math.PI * value / 180.0;
                if (this.mMaxTreeWedge != value)
                {
                    this.mMaxTreeWedge = value;
                    this.MarkDirty();
                }
            }
        }
        /// <summary>
        /// Gets or sets the <see cref="RootAngle"/> parameter of this
        /// layout algorithm in degrees instead of radians for debugging.
        /// </summary>
        public double DegRootAngle
        {
            get { return 180.0 * this.mRootAngle / Math.PI; }
            set
            {
                value = Math.PI * value / 180.0;
                if (this.mRootAngle != value)
                {
                    this.mRootAngle = value;
                }
            }
        }
        #endregion

        #endregion

        protected override void OnRootChanged(Node oldRoot)
        {
            if (this.RootFindingMethod == TreeRootFinding.UserDefined)
            {
                this.bCircleTreeDirty = true;
                this.MarkDirty();
            }
            base.OnRootChanged(oldRoot);
        }

        protected override void OnBeginIteration(uint iteration, 
            bool dirty, int lastNodeCount, int lastEdgeCount)
        {
            bool graphDirty = 
                this.mGraph.NodeCount != lastNodeCount ||
                this.mGraph.EdgeCount != lastEdgeCount;
            if (this.bSpanTreeDirty || graphDirty)
            {
                this.GenerateSpanningTree();
                this.bSpanTreeDirty = false;
            }
            if (this.bCircleTreeDirty || graphDirty)
            {
                this.BuildBalloonTree();
                this.bCircleTreeDirty = false;
            }
            if (dirty || graphDirty)
            {
                this.CalculatePositions(this.mCircleTree);
            }
            if (this.bCenterDirty ||
                this.mGraph.NodeCount != lastNodeCount)
            {
                // Calculate the initial position of
                // the center of the entire balloon tree
                switch (this.mRootCentering)
                {
                    case CircleCentering.BBoxCenter:
                        Box2F bbox = this.mClusterNode == null
                            ? this.BoundingBox 
                            : this.mClusterNode.LayoutBBox;
                        this.mCX = bbox.X + bbox.W / 2.0;
                        this.mCY = bbox.Y + bbox.H / 2.0;
                        break;
                    case CircleCentering.Centroid:
                        Node node;
                        Digraph<Node, Edge>.GNode[] nodes
                            = this.mGraph.InternalNodes;
                        // Initialize the center as the centroid of the nodes
                        this.mCX = this.mCY = 0;
                        for (int i = 0; i < nodes.Length; i++)
                        {
                            node = nodes[i].mData;
                            //pos = nodes[i].SceneTranslate();
                            this.mCX += node.X;//pos.Width;
                            this.mCY += node.Y;//pos.Height;
                        }
                        this.mCX /= nodes.Length;
                        this.mCY /= nodes.Length;
                        break;
                }
            }
            base.OnBeginIteration(iteration, dirty, 
                lastNodeCount, lastEdgeCount);
        }

        private void PullOnRoots(CircleTree<Node, Edge> tree)
        {
            // If fixed, adjust angle/distance of ancestors,
            // Else iterate through its branches and recursively check
            // if they are fixed, repeating the process up to leaf nodes

            // Recursive branch iteration is not done for fixed subtrees
            // because the fixation of their branches is irrelevant, 
            // since their fixed branches can't adjust their fixed root.

            Node node = tree.NodeData;
            if (node.PositionFixed)
            {
                double ang, cx, cy, dx, dy, r, force, fx, fy;
                CircleTree<Node, Edge> ct = tree;
                CircleTree<Node, Edge> root = ct.Root;
                while (root != null)
                {
                    // Calculate force on root
                    cx = root.NodeData.NewX;
                    cy = root.NodeData.NewY;
                    if (root.Root == null)
                    {
                        ang = this.mRootAngle;
                    }
                    else
                    {
                        node = root.Root.NodeData;
                        ang = Math.Atan2(cy - node.NewY, cx - node.NewX);
                    }
                    node = ct.NodeData;
                    // TODO: make sure all the signs (+/-) are right
                    dx = cx - node.NewX;
                    dy = cy - node.NewY;
                    if (dx == 0 && dy == 0)
                    {
                        fx = fy = ct.Distance / 10;
                    }
                    else
                    {
                        
                        if (this.bAdjustAngle && root.Root == null)
                        {
                            this.mRootAngle = Math.Atan2(-dy, -dx) 
                                - ct.Angle;
                            while (this.mRootAngle < -Math.PI)
                                this.mRootAngle += 2 * Math.PI;
                            while (this.mRootAngle > Math.PI)
                                this.mRootAngle -= 2 * Math.PI;
                            fx = fy = 0;
                            r = Math.Sqrt(dx * dy + dy * dy);
                        }
                        else
                        {
                            r = dx * dx + dy * dy;
                            // Magnetic Torque
                            force = ct.Angle + ang;
                            // dx and dy have to be negated here in
                            // order to get the same results as the 
                            // single step method that uses Cos/Sin
                            force = Math.Atan2(-dy, -dx) - force;
                            while (force < -Math.PI)
                                force += 2 * Math.PI;
                            while (force > Math.PI)
                                force -= 2 * Math.PI;
                            force = this.mMagnetMult *
                                Math.Pow(force, this.mMagnetExp) / r;
                            fx = force * -dy;
                            fy = force * dx;
                            r = Math.Sqrt(r);
                        }
                        // Spring Force
                        force = this.mSpringMult *
                            Math.Log(r / ct.Distance);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Apply force to root position
                    node = root.NodeData;
                    node.SetNewPosition(node.NewX - (float)fx, 
                                        node.NewY - (float)fy);
                    // Progress up the ancestry chain
                    ct = root;
                    root = ct.Root;
                }
            }
            else
            {
                CircleTree<Node, Edge>[] branches = tree.Branches;
                for (int i = 0; i < branches.Length; i++)
                {
                    this.PullOnRoots(branches[i]);
                }
            }
        }

        private Stack<CircleTree<Node, Edge>> mStack;
        private Queue<CircleTree<Node, Edge>> mQueue;

        protected override void PerformIteration(uint iteration)
        {
            int i;
            Node node;
            CircleTree<Node, Edge> ct, root;
            CircleTree<Node, Edge>[] branches;
            double ang, cx, cy, dx, dy, r, force, fx, fy;
            Digraph<Node, Edge>.GNode[] nodes = this.mGraph.InternalNodes;

            // Initially set new positions to current positions, since
            // some of them might be adjusted instead of directly set
            for (i = 0; i < nodes.Length; i++)
            {
                node = nodes[i].mData;
                node.SetNewPosition(node.X, node.Y);
            }

            node = this.mCircleTree.NodeData;
            if (!node.PositionFixed)
            {
                // Pull the root of the entire balloon tree
                // towards its calculated center.
                Box2F bbox = null;
                switch (this.mRootCentering)
                {
                    case CircleCentering.BBoxCenter:
                        bbox = this.mClusterNode == null
                            ? this.BoundingBox
                            : this.mClusterNode.LayoutBBox;
                        break;
                    case CircleCentering.Centroid:
                        bbox = this.mClusterNode == null
                            ? this.BoundingBox
                            : this.mClusterNode.LayoutBBox;
                        // TODO: What if the centroid is outside the bbox?
                        dx = this.mCX - bbox.X;
                        dy = this.mCY - bbox.Y;
                        if (bbox.Right - this.mCX < dx)
                            dx = bbox.Right - this.mCX;
                        if (bbox.Bottom - this.mCY < dy)
                            dy = bbox.Bottom - this.mCY;
                        bbox = new Box2F(
                            (float)(this.mCX - dx), (float)(this.mCY - dy),
                            (float)(2.0 * dx), (float)(2.0 * dy));
                        break;
                    // No need to calculate for Predefined, as the center 
                    // is the current position of the root node
                }
                if (bbox != null)
                {
                    ang = Math.Sqrt(bbox.W * bbox.W + bbox.H * bbox.H) / 2;
                    fx = fy = 0.0;
                    // Spring Force from Top Left Corner
                    dx = bbox.X - node.X;
                    dy = bbox.Y - node.Y;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Spring Force from Top Right Corner
                    dx += bbox.W;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Spring Force from Bottom Right Corner
                    dy += bbox.H;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Spring Force from Bottom Left Corner
                    dx -= bbox.W;
                    r = Math.Sqrt(dx * dx + dy * dy);
                    if (r > 0.0)
                    {
                        force = this.mSpringMult * Math.Log(r / ang);
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                    // Apply force to root position
                    node.SetNewPosition(node.X + (float)fx, 
                                        node.Y + (float)fy);
                }
            }
            if (this.bAdjustRoots)
            {
                // Pull roots towards their fixed branches
                //this.PullOnRoots(this.mCircleTree);
                if (this.mStack == null)
                {
                    this.mStack = new Stack<CircleTree<Node, Edge>>(
                        nodes.Length);
                }
                this.mStack.Push(this.mCircleTree);
                while (this.mStack.Count > 0)
                {
                    root = this.mStack.Pop();
                    if (root.NodeData.PositionFixed)
                    {
                        ct = root;
                        root = ct.Root;
                        while (root != null)
                        {
                            // Calculate force on root
                            cx = root.NodeData.NewX;
                            cy = root.NodeData.NewY;
                            if (root.Root == null)
                            {
                                ang = this.mRootAngle;
                            }
                            else
                            {
                                node = root.Root.NodeData;
                                ang = Math.Atan2(cy - node.NewY,
                                                 cx - node.NewX);
                            }
                            node = ct.NodeData;
                            // TODO: make sure all the signs (+/-) are right
                            dx = cx - node.NewX;
                            dy = cy - node.NewY;
                            if (dx == 0 && dy == 0)
                            {
                                fx = fy = ct.Distance / 10;
                            }
                            else
                            {
                                if (this.bAdjustAngle && root.Root == null)
                                {
                                    this.mRootAngle = Math.Atan2(-dy, -dx)
                                        - ct.Angle;
                                    while (this.mRootAngle < -Math.PI)
                                        this.mRootAngle += 2 * Math.PI;
                                    while (this.mRootAngle > Math.PI)
                                        this.mRootAngle -= 2 * Math.PI;
                                    fx = fy = 0;
                                    r = Math.Sqrt(dx * dx + dy * dy);
                                }
                                else
                                {
                                    r = dx * dx + dy * dy;
                                    // Magnetic Torque
                                    force = ct.Angle + ang;
                                    // dx and dy have to be negated here in
                                    // order to get the same results as the 
                                    // single step method that uses Cos/Sin
                                    force = Math.Atan2(-dy, -dx) - force;
                                    while (force < -Math.PI)
                                        force += 2 * Math.PI;
                                    while (force > Math.PI)
                                        force -= 2 * Math.PI;
                                    force = this.mMagnetMult *
                                        Math.Pow(force, this.mMagnetExp) / r;
                                    fx = force * -dy;
                                    fy = force * dx;
                                    r = Math.Sqrt(r);
                                }
                                // Spring Force
                                force = this.mSpringMult *
                                    Math.Log(r / ct.Distance);
                                fx += force * dx / r;
                                fy += force * dy / r;
                            }
                            // Apply force to root position
                            node = root.NodeData;
                            node.SetNewPosition(node.NewX - (float)fx,
                                                node.NewY - (float)fy);
                            // Progress up the ancestry chain
                            ct = root;
                            root = ct.Root;
                        }
                    }
                    else
                    {
                        branches = root.Branches;
                        for (i = branches.Length - 1; i >= 0; i--)
                        {
                            this.mStack.Push(branches[i]);
                        }
                    }
                }/* */
            }
            // Pull movable branches towards their roots
            if (this.mQueue == null)
            {
                this.mQueue = new Queue<CircleTree<Node, Edge>>(
                    nodes.Length);
            }
            this.mQueue.Enqueue(this.mCircleTree);
            while (this.mQueue.Count > 0)
            {
                ct = this.mQueue.Dequeue();
                cx = ct.NodeData.NewX;
                cy = ct.NodeData.NewY;
                if (ct.Root == null)
                {
                    ang = this.mRootAngle;
                }
                else
                {
                    node = ct.Root.NodeData;
                    ang = Math.Atan2(cy - node.NewY, cx - node.NewX);
                }
                branches = ct.Branches;
                for (i = 0; i < branches.Length; i++)
                {
                    ct = branches[i];
                    node = ct.NodeData;
                    if (!node.PositionFixed)
                    {
                        // TODO: make sure all the signs (+/-) are right
                        dx = cx - node.NewX;
                        dy = cy - node.NewY;
                        if (dx == 0 && dy == 0)
                        {
                            fx = fy = ct.Distance / 10;
                        }
                        else
                        {
                            r = dx * dx + dy * dy;
                            // Magnetic Torque
                            force = ct.Angle + ang;
                            // dx and dy have to be negated here in
                            // order to get the same results as the 
                            // single step method that uses Cos/Sin
                            force = Math.Atan2(-dy, -dx) - force;
                            while (force < -Math.PI)
                                force += 2 * Math.PI;
                            while (force > Math.PI)
                                force -= 2 * Math.PI;
                            force = this.mMagnetMult * 
                                Math.Pow(force, this.mMagnetExp) / r;
                            fx = force * -dy;
                            fy = force * dx;
                            // Spring Force
                            r = Math.Sqrt(r);
                            force = this.mSpringMult * 
                                Math.Log(r / ct.Distance);
                            fx += force * dx / r;
                            fy += force * dy / r;
                        }
                        // Add force to position
                        node.SetNewPosition((float)(node.NewX + fx),
                                            (float)(node.NewY + fy));/* */

                        /*dx = cx + ct.Distance * Math.Cos(ct.Angle + ang);
                        dy = cy + ct.Distance * Math.Sin(ct.Angle + ang);
                        node.SetNewPosition((float)dx, (float)dy);/* */
                    }
                    this.mQueue.Enqueue(ct);
                }
            }
        }

        private void GenerateSpanningTree()
        {
            ISpanningTreeAlgorithm<Node, Edge> alg = null;
            switch (this.mSpanTreeGen)
            {
                case SpanningTreeGen.BFS:
                    BFSpanningTree<Node, Edge> bfst
                        = new BFSpanningTree<Node, Edge>(
                            this.mGraph, false, false);
                    Digraph<Node, Edge>.GNode r1 = this.TryGetGraphRoot();
                    bfst.SetRoot(r1.mData);
                    alg = bfst;
                    break;
                case SpanningTreeGen.DFS:
                    DFSpanningTree<Node, Edge> dfst
                        = new DFSpanningTree<Node, Edge>(
                            this.mGraph, false, false);
                    Digraph<Node, Edge>.GNode r2 = this.TryGetGraphRoot();
                    dfst.SetRoot(r2.mData);
                    alg = dfst;
                    break;
                case SpanningTreeGen.Boruvka:
                    alg = new BoruvkaMinSpanningTree<Node, Edge>(mGraph);
                    break;
                case SpanningTreeGen.Kruskal:
                    alg = new KruskalMinSpanningTree<Node, Edge>(mGraph);
                    break;
                case SpanningTreeGen.Prim:
                    alg = new PrimMinSpanningTree<Node, Edge>(mGraph);
                    break;
            }
            alg.Compute();
            this.mSpanTree = alg.SpanningTree;
        }

        private void BuildBalloonTree()
        {
            int i, rootIndex;
            Digraph<Node, Edge>.GNode root = null;
            Digraph<Node, Edge>.GNode[] nodes
                = this.mSpanTree.InternalNodes;
            for (i = 0; i < nodes.Length; i++)
            {
                root = nodes[i];
                root.Index = i;
                root.Color = GraphColor.White;
            }
            switch (this.mRootFindingMethod)
            {
                case TreeRootFinding.UserDefined:
                    rootIndex = this.HasRoot
                        ? this.mSpanTree.IndexOfNode(this.TryGetRoot())
                        : 0;
                    if (rootIndex < 0)
                        rootIndex = 0;
                    root = nodes[rootIndex];
                    break;
                case TreeRootFinding.Center:
                    root = this.mSpanTree.FindCenter(false, false);
                    if (root == null)
                    {
                        root = nodes[0];
                        rootIndex = 0;
                    }
                    else
                    {
                        rootIndex = root.Index;
                    }
                    break;
            }
            this.mSpanTreeEdges = this.mSpanTree.InternalEdges;
            this.mCircleTree = this.BuildBranch(root, default(Edge));
            this.mSpanTreeEdges = null;
        }

        private CircleTree<Node, Edge> BuildBranch(
            Digraph<Node, Edge>.GNode root, Edge edge)
        {
            root.Color = GraphColor.Gray;

            CircleTree<Node, Edge> child, parent 
                = new CircleTree<Node, Edge>(root.mData, edge, 
                    this.GetBoundingRadius(root.mData), root.AllEdgeCount);

            // Recursively add child branches.
            int i;
            Digraph<Node, Edge>.GEdge e;
            Digraph<Node, Edge>.GNode node;

            for (i = 0; i < this.mSpanTreeEdges.Length; i++)
            {
                e = this.mSpanTreeEdges[i];
                if (e.mSrcNode.Index == root.Index)
                {
                    node = e.mDstNode;
                    if (node.Color == GraphColor.White)
                    {
                        child = this.BuildBranch(node, e.mData);
                        child.SetRoot(parent);
                    }
                }
                else if (e.mDstNode.Index == root.Index)
                {
                    node = e.mSrcNode;
                    if (node.Color == GraphColor.White)
                    {
                        child = this.BuildBranch(node, e.mData);
                        child.SetRoot(parent);
                    }
                }
            }
            root.Color = GraphColor.Black;

            return parent;
        }

        /// <summary>
        /// Calculates the radius of a circle that encloses the given
        /// <paramref name="node"/>, which is used to calculate the convex
        /// hulls of the subtrees that include the given node in their
        /// branches.</summary>
        /// <param name="node">The node enclosed within a circle of the
        /// returned radius.</param>
        /// <returns>The radius of the bounding circle of the given
        /// <paramref name="node"/>, which by default is the smallest circle
        /// that circumscribes the given node's bounding box.</returns>
        /// <remarks><para>
        /// This function is only used when the layout algorithm builds its
        /// balloon tree data structure, which is only done when its 
        /// <see cref="P:LayoutAlgorithm`2.Graph"/> and/or the values of its
        /// <see cref="SpanningTreeGeneration"/> and/or 
        /// <see cref="RootFindingMethod"/> parameters are changed.
        /// </para><para>
        /// By default, this function simply returns half the length of the
        /// diagonal of the given <paramref name="node"/>'s 
        /// <see cref="ILayoutNode.LayoutBBox"/>, which is the radius of the
        /// smallest circle that circumscribes it.  It does not compensate
        /// for the possibility that the node's "center" might not be the
        /// center of its bounding box (the box's <see cref="Box2F.X"/>
        /// might not be equal to <c>-<see cref="Box2F.W"/> / 2</c>, or its
        /// <see cref="Box2F.Y"/> might not be equal to 
        /// <c>-<see cref="Box2F.H"/> / 2</c>).</para><para>
        /// This method can be overridden to take that into account, and/or
        /// to provide a more efficient bounding radius calculation for
        /// certain nodes. However, be aware that if this function ever
        /// returns a value less than or equal to zero, an
        /// <see cref="ArgumentOutOfRangeException"/> will be thrown when
        /// the layout algorithm attempts to use that invalid radius.
        /// </para></remarks>
        protected virtual double GetBoundingRadius(Node node)
        {
            Box2F bbox = node.LayoutBBox;
            return Math.Sqrt(bbox.W * bbox.W + bbox.H * bbox.H) / 2.0;
        }

        private void CalculatePositions(CircleTree<Node, Edge> root)
        {
            if (root.BranchCount == 0)
            {
                root.CalculateConvexHull();
            }
            else
            {
                CircleTree<Node, Edge>[] branches = root.Branches;
                for (int i = 0; i < branches.Length; i++)
                {
                    this.CalculatePositions(branches[i]);
                }
                this.CalculateBranchPositions(branches);
                root.CalculateConvexHull();
            }
        }

        /// <summary>
        /// Calculates the polar coordinates (the 
        /// <see cref="P:CircleTree`2{Node,Edge}.Angle"/> and 
        /// <see cref="P:CircleTree`2{Node,Edge}.Distance"/>) of each
        /// subtree or leaves in the given array of 
        /// <paramref name="branches"/>.</summary>
        /// <param name="branches">An array of layout node subtrees or leaves
        /// that share the same <see cref="P:CircleTree`2{Node,Edge}.Root"/>.
        /// </param><remarks><para>
        /// For classes that reimplement this function, be aware that this
        /// function is invoked recursively from the root down to the leaves
        /// of the layout tree, so the polar coordinates of the positions of 
        /// the <see cref="P:CircleTree`2{Node,Edge}.Branches"/> of each 
        /// subtree in the given <paramref name="branches"/> have already 
        /// been calculated by a previous invocation of this function, and 
        /// then the <see cref="P:CircleTree`2{Node,Edge}.ConvexHull"/> of 
        /// each subtree was calculated based on those positions.
        /// </para><para>
        /// In general, take great care when reimplementing this function, as
        /// it is the most important function of the entire balloon tree
        /// layout algorithm. The polar coordinate positions of the given
        /// <paramref name="branches"/> calculated by this function are not 
        /// only used to calculate the convex hull of their shared
        /// <see cref="P:CircleTree`2{Node,Edge}.Root"/>, but they are also 
        /// used to determine the final positions of the layout nodes at 
        /// their centers.</para></remarks>
        protected virtual void CalculateBranchPositions(
            CircleTree<Node, Edge>[] branches)
        {
            int i, j;
            // Set the initial distance of each branch based on MinEdgeLen
            Box2F bbox;
            CircleTree<Node, Edge> ct;
            double rootRad = branches[0].Root.Radius + this.mMinEdgeLen;
            double maxDist = -double.MaxValue;
            for (i = 0; i < branches.Length; i++)
            {
                ct = branches[i];
                bbox = ct.CalculateBoundingBox();
                ct.Distance = rootRad - bbox.X;
                if (ct.Distance > maxDist)
                    maxDist = ct.Distance;
            }
            // Calculate the initial bounding wedges of the branches
            if (this.bEqualizeBranches)
            {
                for (i = 0; i < branches.Length; i++)
                {
                    ct = branches[i];
                    ct.Distance = maxDist;
                    ct.CalculateAngles();
                }
            }
            else
            {
                for (i = 0; i < branches.Length; i++)
                {
                    branches[i].CalculateAngles();
                }
            }
            // Sort the branches to their final order counterclockwise
            // around their root starting at -pi (-180 degrees).
            this.SortBranches(branches);
            // Get the maximum allowable wedge that the branches can occupy
            double maxWedge = this.GetMaximumTreeWedge(branches[0].Root);
            while (maxWedge < 0.0)
                maxWedge += 2 * Math.PI;
            while (maxWedge > 2 * Math.PI)
                maxWedge -= 2 * Math.PI;
            // Set the final polar coordinate positions of the branches
            double wedge, ratio;
            switch (this.mBranchSpacing)
            {
                case CircleSpacing.Fractal:
                    double a;
                    // Calculate the final distances of the branches
                    wedge = maxWedge / (2 * branches.Length);
                    ratio = Math.Sin(wedge);
                    for (i = 0; i < branches.Length; i++)
                    {
                        ct = branches[i];
                        a = Math.Max(ct.LowerWedge, ct.UpperWedge);
                        //while (a > wedge)
                        for (j = 0; j < 50 && a > wedge; j++)
                        {
                            ct.Distance = ct.Distance * Math.Sin(a) / ratio;
                            ct.CalculateAngles();
                            a = Math.Max(ct.LowerWedge, ct.UpperWedge);
                        }
                        if (ct.Distance > maxDist)
                            maxDist = ct.Distance;
                    }
                    if (this.bEqualizeBranches)
                    {
                        for (i = 0; i < branches.Length; i++)
                        {
                            branches[i].Distance = maxDist;
                        }
                    }
                    // Calculate the final angles of the branches
                    a = maxWedge / -2.0;
                    for (i = 0; i < branches.Length; i++)
                    {
                        a += wedge;
                        branches[i].Angle = a;
                        a += wedge;
                    }
                    break;
                case CircleSpacing.SNS:
                    // Calculate the final distances of the branches
                    wedge = 0.0;
                    for (i = 0; i < branches.Length; i++)
                    {
                        ct = branches[i];
                        wedge += ct.LowerWedge + ct.UpperWedge;
                    }
                    //while (wedge > maxWedge)
                    for (j = 0; j < 50 && wedge > maxWedge; j++)
                    {
                        ratio = wedge / maxWedge;
                        wedge = 0.0;
                        for (i = 0; i < branches.Length; i++)
                        {
                            ct = branches[i];
                            ct.Distance = ct.Distance * ratio;
                            ct.CalculateAngles();
                            wedge += ct.LowerWedge + ct.UpperWedge;
                        }
                    }
                    // Calculate the final angles of the branches
                    ratio = (maxWedge - wedge) / (2 * branches.Length);
                    wedge = maxWedge / -2.0;
                    for (i = 0; i < branches.Length; i++)
                    {
                        ct = branches[i];
                        wedge += ct.LowerWedge + ratio;
                        ct.Angle = wedge;
                        wedge += ct.UpperWedge + ratio;
                    }
                    break;
            }
        }

        /// <summary><para>
        /// Gets the maximum allowable wedge in radians that the
        /// <see cref="P:CircleTree`2{Node,Edge}.Branches"/> of the given 
        /// <paramref name="root"/> can occupy around it.</para><para>
        /// Be aware that this angle will be normalized to the range [0,2π] 
        /// ( [0°,360°] ) when used.</para></summary>
        /// <param name="root">The root to get maximum allowable wedge that
        /// its branches can occupy around it.</param>
        /// <returns>The maximum allowable wedge in radians that the branches
        /// of the given <paramref name="root"/> can occupy around it.
        /// </returns><remarks>
        /// By default, this function simply returns 
        /// <see cref="MaximumRootWedge"/> for the root of the entire balloon
        /// tree and <see cref="MaximumTreeWedge"/> for the roots of every
        /// subtree in the balloon tree, except when the subtree has exactly
        /// two branches. In that case it returns π (180°) if 
        /// <see cref="MaximumTreeWedge"/> is greater than that amount (when
        /// normalized) in order to make the tree look better. 
        /// See those properties for further details on what the 
        /// <see cref="M:CalculateBranchPositions(CircleTree`2[])"/>
        /// function does with the wedge angle this function returns.
        /// </remarks><seealso cref="MaximumRootWedge"/>
        /// <seealso cref="MaximumTreeWedge"/>
        protected virtual double GetMaximumTreeWedge(
            CircleTree<Node, Edge> root)
        {
            if (root.Root == null)
                return this.mMaxRootWedge;
            if (root.BranchCount == 2)
            {
                double ang = this.mMaxTreeWedge;
                while (ang < 0.0)
                    ang += 2 * Math.PI;
                while (ang > 2 * Math.PI)
                    ang -= 2 * Math.PI;
                return Math.Min(Math.PI, ang);
            }
            return this.mMaxTreeWedge;
        }

        /// <summary>
        /// This comparer sorts subtree/leaf nodes by their angles in radians
        /// around their shared root node, measured counterclockwise from the
        /// +X-axis using <c>Atan2(leaf.Y - <see cref="SketchSorter.CX"/>,
        /// leaf.X - <see cref="SketchSorter.CY"/>)</c>.
        /// </summary><remarks>
        /// This comparer is provided for any descendant balloon tree layout
        /// algorithms that reimplement the 
        /// <see cref="M:SortBranches(CircleTree`2{Node,Edge}[])"/> function 
        /// and still support <see cref="InSketchMode"/> property.
        /// Anything that uses this comparer should give meaningful values to
        /// its <see cref="SketchSorter.CX"/>, <see cref="SketchSorter.CY"/>,
        /// and <see cref="SketchSorter.RootAngle"/> fields before using it
        /// to sort of a set of <see cref="T:CircleTree`2{Node,Edge}"/>
        /// instances that share the same 
        /// <see cref="P:CircleTree`2{Node,Edge}.Root"/>.</remarks>
        public class SketchSorter : IComparer<CircleTree<Node, Edge>>
        {
            /// <summary>
            /// The X-coordinate of the center of the shared root of x and y.
            /// </summary>
            public float CX = 0;
            /// <summary>
            /// The Y-coordinate of the center of the shared root of x and y.
            /// </summary>
            public float CY = 0;
            /// <summary><para>
            /// The angle in radians measured counterclockwise from the 
            /// +X-axis of the ray from the center of the shared root of 
            /// x and y to the center of its own root,</para><para>which  
            /// basically represents the direction of the -X-axis of the
            /// local coordinate system of the shared root of x and y.
            /// </para><para>
            /// This is used to make sure that x and y are on the same side
            /// of the -X-axis of the local coordinate system of their shared
            /// root so that they are correctly compared.
            /// </para><para>
            /// If the shared root of x and y has no root of its own (it is
            /// the base root of the entire balloon tree), -π (-180°) should
            /// be used in order to reduce the number of normalization
            /// operations performed on the angles of x and y.
            /// </para></summary>
            public double RootAngle = -Math.PI;

            private double xAng, yAng;
            /// <summary>
            /// Compares the two given subtree/leaf nodes based their current
            /// angles (measured counterclockwise from the +X-axis) around
            /// their shared <see cref="P:CircleTree`2.Root"/>.</summary>
            /// <param name="x">A node to compare by angle.</param>
            /// <param name="y">A node to compare by angle.</param>
            /// <returns>0 if <paramref name="x"/> and <paramref name="y"/>
            /// are at the same angle around their root; 1 if 
            /// <paramref name="x"/> is at a greater angle than 
            /// <paramref name="y"/>; -1 if <paramref name="x"/> is at a
            /// lesser angle than <paramref name="y"/>.</returns>
            public int Compare(CircleTree<Node, Edge> x, 
                               CircleTree<Node, Edge> y)
            {
                xAng = Math.Atan2(x.NodeData.Y - this.CY, x.NodeData.X - this.CX);
                if (xAng < this.RootAngle)
                    xAng += 2 * Math.PI;
                yAng = Math.Atan2(y.NodeData.Y - this.CY, y.NodeData.X - this.CX);
                if (yAng < this.RootAngle)
                    yAng += 2 * Math.PI;
                return xAng == yAng ? 0 : (xAng < yAng ? -1 : 1);
            }
        }
        private SketchSorter mSketchSorter;

        /// <summary><para>
        /// Used by <see cref="M:CalculateBranchPositions(CircleTree`2[])"/>
        /// to sort the given <paramref name="branches"/> in the order in
        /// which they will be arranged counterclockwise around their shared
        /// root from -π (-180°) to π (180°). </para><para>
        /// This ordering is then used to calculate the polar coordinates of 
        /// the position of each subtree or leaf in 
        /// <paramref name="branches"/>.</para></summary>
        /// <param name="branches">An array of layout node subtrees or leaves
        /// that share the same <see cref="P:CircleTree`2{Node,Edge}.Root"/>.
        /// </param><remarks>
        /// Be aware that if this function is reimplemented, it will make
        /// <see cref="InSketchMode"/> and <see cref="BranchSorter"/>
        /// meaningless, unless the reimplementation uses their values.
        /// </remarks>
        protected virtual void SortBranches(
            CircleTree<Node, Edge>[] branches)
        {
            if (this.bInSketchMode)
            {
                if (this.mSketchSorter == null)
                    this.mSketchSorter = new SketchSorter();
                CircleTree<Node, Edge> root = branches[0].Root;
                this.mSketchSorter.CX = root.NodeData.X;
                this.mSketchSorter.CY = root.NodeData.Y;
                if (root.Root == null)
                {
                    this.mSketchSorter.RootAngle = -Math.PI;
                }
                else
                {
                    this.mSketchSorter.RootAngle = Math.Atan2(
                        root.Root.NodeData.Y - this.mSketchSorter.CY,
                        root.Root.NodeData.X - this.mSketchSorter.CX);
                }
                Array.Sort<CircleTree<Node, Edge>>(branches, 0, 
                    branches.Length, this.mSketchSorter);
            }
            else if (this.mBranchSorter != null)
            {
                Array.Sort<CircleTree<Node, Edge>>(branches, 0, 
                    branches.Length, this.mBranchSorter);
            }
        }
    }
}
