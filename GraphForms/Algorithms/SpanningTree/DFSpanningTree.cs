using System;
using GraphForms.Algorithms.Search;

namespace GraphForms.Algorithms.SpanningTree
{
    /// <summary>
    /// This algorithm uses a simple depth first traversal of a given graph
    /// to generate a spanning tree.</summary>
    /// <typeparam name="Node">The type of vertices in the spanning tree 
    /// generated by this algorithm.</typeparam>
    /// <typeparam name="Edge">The type of edges in the spanning tree 
    /// generated by this algorithm.</typeparam>
    public class DFSpanningTree<Node, Edge>
        : DepthFirstSearch<Node, Edge>,
          ISpanningTreeAlgorithm<Node, Edge>
        where Edge : IGraphEdge<Node>
    {
        private static readonly Digraph<Node, Edge>.GEdge[] sEmptySTEs
            = new Digraph<Node, Edge>.GEdge[0];

        private Digraph<Node, Edge> mSpanningTree;

        private int mSTECount;
        private Digraph<Node, Edge>.GEdge[] mSpanTreeEdges;

        public DFSpanningTree(Digraph<Node, Edge> graph)
            : base(graph, true, false)
        {
            this.mSpanningTree = new Digraph<Node, Edge>(
                graph.NodeCount, graph.EdgeCount / 2);

            this.mSTECount = 0;
            this.mSpanTreeEdges = sEmptySTEs;
        }

        public DFSpanningTree(Digraph<Node, Edge> graph,
            bool directed, bool reversed)
            : base(graph, directed, reversed)
        {
            this.mSpanningTree = new Digraph<Node, Edge>(
                graph.NodeCount, graph.EdgeCount / 2);

            this.mSTECount = 0;
            this.mSpanTreeEdges = sEmptySTEs;
        }

        /// <summary>
        /// A sub-graph of the original connected graph that connects all
        /// its vertices together with a minimal subset of its edges.
        /// </summary><remarks>
        /// If the original graph isn't connected, this graph will contain
        /// multiple spanning trees, one for each (weakly) connected
        /// component of the original graph.
        /// </remarks>
        public Digraph<Node, Edge> SpanningTree
        {
            get { return this.mSpanningTree; }
        }

        public Digraph<Node, Edge>.GEdge[] SpanningTreeEdges
        {
            get
            {
                Digraph<Node, Edge>.GEdge[] stEdges
                    = new Digraph<Node, Edge>.GEdge[this.mSTECount];
                if (this.mSTECount > 0)
                {
                    Array.Copy(this.mSpanTreeEdges, 0,
                        stEdges, 0, this.mSTECount);
                }
                return stEdges;
            }
        }

        public override void Initialize()
        {
            base.Initialize();

            this.mSTECount = Math.Min(
                this.mGraph.NodeCount - 1, this.mGraph.EdgeCount);
            if (this.mSpanTreeEdges.Length < this.mSTECount)
            {
                this.mSpanTreeEdges
                    = new Digraph<Node, Edge>.GEdge[this.mSTECount];
            }
            this.mSTECount = 0;
        }

        /// <summary>
        /// Called whenever the algorithm explores an edge in the graph
        /// connected to an unexplored node, that edge is then added to the
        /// spanning tree.
        /// </summary>
        /// <param name="e">The edge being explored by this graph traversal 
        /// algorithm.</param>
        /// <param name="reversed">True if the edge is being explored from 
        /// destination to source instead of from source to destination.
        /// </param>
        protected override void OnTreeEdge(Digraph<Node, Edge>.GEdge e, 
            bool reversed, uint depth)
        {
            this.mSpanningTree.AddEdge(e.Data);
            this.mSpanTreeEdges[this.mSTECount++] = e;
        }
    }
}
